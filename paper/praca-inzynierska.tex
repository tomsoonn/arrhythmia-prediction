\documentclass[polish,12pt]{aghthesis}
% \documentclass[english,12pt]{aghthesis} dla pracy w jêzyku angielskim. Uwaga, w przypadku strony tytu³owej zmiana jêzyka dotyczy tylko kolejno¶ci wersji jêzykowych tytu³u pracy. 

% Szablon przystosowany jest do druku dwustronnego. 

\usepackage[latin2]{inputenc}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{siunitx}
\usepackage{caption}

\renewcommand{\arraystretch}{1.3}
\renewcommand{\lstlistingname}{Fragment}
\newcommand{\sectionbreak}{\clearpage} 

\lstdefinestyle{custompy}{
	language=python,
	tabsize=4,
	basicstyle=\footnotesize,
	keywordstyle=\color{blue},
	breaklines=true,
	frame=single,
	showstringspaces=false,
	breakatwhitespace=true,
	xleftmargin=\parindent,
	belowskip=\baselineskip
}
\lstdefinestyle{result}{
	basicstyle=\footnotesize,
	morekeywords={loss, binary_accuracy, mean_squared_error, precision, recall, fmeasure},
	keywordstyle=\color{green!50!black}
}
\captionsetup{justification=centering}

\lstset{captionpos=b, style=custompy}

\author{Konrad Dobro¶, Tomasz Nizio}

\titlePL{System do predykcji arytmii serca za pomoc± metod uczenia maszynowego}
\titleEN{System for predicting cardiac arrhythmia using machine learning methods}

\fieldofstudy{Informatyka}

\supervisor{dr in¿.\ Marcin Orchel}

\date{\the\year}
\raggedbottom

\begin{document}

\maketitle

\tableofcontents
\newpage


\section{\SectionTitleProjectVision}
\label{sec:cel-wizja}
\subsection{Charakterystyka problemu}

% Czym jest arytmia
Arytmia serca jest to stan, w którym praca serca jest nieregularna, a czêstotliwo¶æ wychodzi poza zakres 60-100 uderzeñ na minutê bez przyczyny zewnêtrznej. Stan taki mo¿e stanowiæ zagro¿enie dla ¿ycia, chocia¿ nie jest to regu³±. 
Stan w którym tempo bicia serca wynosi ponad 100 uderzeñ na minutê nazywany jest tachykardi±. D³u¿sza praca serca w przyspieszonym rytmie mo¿e prowadziæ do szkodliwych efektów. Tachykardia mo¿e byæ odczuwana jako nieprzyjemne i mocne bicie serca popularnie okre¶lane ko³ataniem.
Zbyt wolny rytm pracy serca, który wynosi poni¿ej 50 uderzeñ na minutê nazywany jest bradykardi±. Zazwyczaj stan ten nie zagra¿a ¿yciu, choæ mo¿e powodowaæ niepo¿±dane objawy.

% EKG
Najczê¶ciej stosowan± metod± diagnozowania arytmii jest elektrokardiogram - zapis elektrycznej czynno¶ci serca. Pozwala on dok³adnie okre¶liæ rodzaj arytmii, a wiêc i jej szkodliwo¶æ oraz potencjalne przyczyny. W wypadku krótkotrwa³ych arytmii stosuje siê monitory holterowskie umo¿liwiaj±ce ca³odobowe monitorowanie pracy serca.

W wypadku krótkotrwa³ych arytmii stosuje siê monitorowanie pracy serca przez ca³± dobê. Podej¶cie takie produkuje ogromn± ilo¶æ danych, do analizy której potrzebna jest specjalistyczna wiedza, a rêczne oznaczenie danych jest bardzo czasoch³onne. Obecnie w procesie tym wykorzystywane s± metody matematyczne, które wykorzystuj± w bardzo ograniczonym zakresie wiedzê dziedzinow± i wymagaj± bardzo uwa¿nego nadzorowania.

% Jaka jest potrzeba
Istnieje potrzeba zautomatyzowania procesu wykrywania arytmii w wiêkszym stopniu i za pomoc± bardziej niezawodnych metod, które wykorzystywa³yby wiedzê dziedzinow±. Proces ten dodatkowo mo¿e byæ usprawniony przez system predykcji wyst±pienia arytmii, który umo¿liwia³by wcze¶niejsze wykrywanie arytmii i reagowanie na jej potencjalne wyst±pienie z wyprzedzeniem. Umo¿liwi³oby to znaczne ograniczenie kosztownego czasu pracy lekarzy i mog³oby zwiêkszyæ jej efektywno¶æ. Poniewa¿ problem ten wymaga posiadania wiedzy dziedzinowej do rozwi±zania bardzo obiecuj±cym podej¶ciem jest wykorzystanie metod uczenia maszynowego. Metody te mog± "uczyæ"\ siê wiedzy specjalistycznej z oznaczonych danych. Jest to szczególnie przydatne, gdy wiedza ta jest ciê¿ka do reprezentacji za pomoc± klasycznych metod, ze wzglêdu na czynniki takie jak du¿a ilo¶æ danych wej¶ciowych, brak jasnych powi±zañ miêdzy danymi czy konieczno¶æ reprezentacji ludzkiego rozumowania.

\subsection{Motywacja projektu}

Podstawow± motywacj± do stworzenia takiego produktu by³ brak podobnych rozwi±zañ dostêpnych obecnie na rynku oraz chêæ rozwijania siê w tematyce uczenia maszynowego.
Bardzo ma³o jest materia³ów dotycz±cych problematyki naszego projektu, który mo¿e staæ podstaw± dla polepszenia zdrowia oraz pozwoli na wcze¶niejsze wykrywanie powa¿niejszych schorzeñ. Nasze rozwi±zanie mo¿e siê przydaæ osobom, które s± zagro¿one arytmi± i obawiaj± siê o swoje zdrowie. Ponadto stworzenie takiego programu pozwoli nam poszerzyæ wiedzê w dziedzinie uczenia maszynowego, które staje siê coraz popularniejsze. W naszym projekcie zdecydowali¶my siê wykorzystaæ sieæ neuronow±, co wydaje siê byæ bardzo ciekawym pomys³em. Coraz wiêcej siê o niej s³yszy oraz technologia to jest coraz lepiej rozwijana i udoskonalana. Rozwi±zanie takie ma bardzo du¿y potencja³, jednak pojawiæ siê mog± te¿ liczne problemy ze stworzeniem takiego systemu. Bardzo wa¿n± kwesti±, je¿eli chodzi o nasz projekt jest odpowiednio oznaczona i du¿a baza danych.
Sieæ neuronowa aby uzyskaæ skuteczno¶æ musi zostaæ wytrenowana na odpowiedniej ilo¶ci danych. Dodatkowo dane te musz± byæ szczegó³owo oznakowane. Jako ¿e nie ma podobnych rozwi±zañ na rynku, nie mamy te¿ pewno¶ci ¿e mo¿liwe jest skuteczne przewidywanie arytmii.

\subsection{Wizja produktu}

Celem naszego projektu jest stworzenie aplikacji na komputery z systemem Windows, wykorzystuj±c± sieæ neuronow± do przewidywania wyst±pienia arytmii serca. Program po odpowiednim przetrenowaniu na zbiorze danych ma byæ w stanie przewidywaæ mo¿liwe nieprawid³owo¶ci w dzia³aniu serca z wyprzedzeniem. U¿ytkownik bêdzie móg³ odczytywaæ predykcje dostarczone przez algorytm. Mo¿liwe równie¿ bêdzie wy¶wietlanie wykresów EKG oraz zarz±dzanie nimi, jak i odczytanie z nich oznaczeñ wyst±pienia arytmii. Docelowo program ma umo¿liwiaæ monitorowanie i analizowanie w czasie rzeczywistym. Aplikacja bêdzie mia³a klasyczny wygl±d aplikacji Windows z menu w górnej czê¶ci. Przebieg wykresu bêdzie mo¿na przewijaæ na pasku, a oznaczenia bêd± obecne pod nim.

\subsection{Studium wykonalno¶ci}

% Jak z³o¿ony jest problem
Projekt ma skomplikowan± problematykê, g³ównie ze wzglêdu na ma³± ilo¶æ badañ i publikacji na ten temat. Dodatkowo problem jest interdyscyplinarny, obejmuj±c w swoim zakresie zagadnienia informatyczne, jak i zagadnienia zwi±zane z medycyn±. Z tego wzglêdu konieczne jest uwa¿ne przestudiowanie wiedzy dziedzinowej, z któr± nie jeste¶my zaznajomieni, a która do pe³nego zrozumienia wymaga osobnych studiów.

Ze wzglêdu na konieczno¶æ posiadania wiedzy specjalistycznej jako wykorzystywan± metodê uczenia maszynowego zosta³a wybrana sieæ neuronowa. Umo¿liwi to wykorzystanie baz danych wykresów EKG ju¿ oznaczonych przez specjalistów z wymagan± wiedz± dziedzinow±. Sieci neuronowe dziêki algorytmom propagacji wstecznej mog± "nauczyæ"\ siê reprezentacji wiedzy specjalistycznej z danych bez wymagania tej wiedzy, i mo¿liwo¶ci jej bezpo¶redniego prze³o¿enia na algorytm, przez implementatora.

Dodatkowo ma³a ilo¶æ dostêpnych publicznie publikacji w zakresie rozwi±zywanego problemu dyktuje wybór technologii. W trakcie wykonywania projektu konieczne jest przetestowanie wielu ró¿nych sposobów rozwi±zania i przeprowadzanie eksperymentów w celu okre¶lenia formy ostatecznego produktu. W sytuacji tej najlepiej sprawdzaj± siê iteracyjne modele organizacyjne, umo¿liwiaj±ce czêst± aktualizacjê projektu do zmieniaj±cych siê mo¿liwo¶ci wynikaj±cych z eksperymentów i zwi±zanych z nimi wymagañ. Podej¶cie takie umo¿liwia równie¿ stopniowe rozszerzanie funkcjonalno¶ci systemu. Ze wzglêdu na brak informacji czy przewidywanie wszystkich rodzajów arytmii jest mo¿liwe, system bêdzie stopniowo rozszerzany o bardziej szczegó³owe analizy na podstawie wyników prototypów i eksperymentów.

Jako jêzyk implementacji systemu wybrany zosta³ Python ze wzglêdu na du¿± ilo¶æ dostêpnych technologi do pracy z sieciami neuronowymi oraz jego du¿± ekspresywno¶æ. Cechy te bardzo dobrze komponuj± siê z modelem wykonywania projektu zmniejszaj±c znacznie czas potrzebny na przetestowanie ró¿nych rozwi±zañ i umo¿liwiaj±c elastyczniejsze podej¶cie do problemu.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\linewidth]{mitdb.jpg}
	\caption{Fragment oznaczonych danych EKG z bazy MIT-BIH}
	\label{fig:mitdb}
	%TODO KD czy tu te¿ trzeba zacytowaæ ten obrazek z strony bazy?
\end{figure}

Do implementacji modelu analizy wykresów i sieci neuronowych wybrany zosta³ zestaw technologi Keras + Tensorflow. Umo¿liwia on bardzo ³atwe tworzenie sieci neuronowych, co jeszcze bardziej zmniejsza czas potrzebny na przetestowanie ró¿nych architektur sieci. S± to aktywnie rozwijane technologie posiadaj±ce bardzo rozleg³e mo¿liwo¶ci, a przy tym posiadaj± szczegó³owe dokumentacje. Dodatkowo biblioteki te s± szeroko wykorzystywane w profesjonalnych rozwi±zaniach co prowadzi do du¿ej liczby dostêpnych informacji i aktywnego wsparcia.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.8\linewidth]{keras-tensor.jpg}
	\caption{Technologie uczenia maszynowego}
	\label{fig:kt}
\end{figure}

Jako technologiê do implementacji aplikacji i interfejsu u¿ytkownika wybrana zosta³a biblioteka PySide2, dostarczaj±ca interfejs dla jêzyka Python do biblioteki Qt. Dziêki temu dostêpna jest rozleg³a dokumentacja, której brakuje w innych rozwa¿anych bibliotekach dla jêzyka Python. Dodatkowo jest to biblioteka aktywnie rozwijana w przeciwieñstwie do przestarza³ej biblioteki dostêpnej domy¶lnie w jêzyku Python - Tkinter. Inn± rozwa¿an± opcj± by³a biblioteka PyQt, jednak nie zosta³a ona finalnie wybrana, gdy¿ posiada zbyt restrykcyjn± licencjê GPL.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.6\linewidth]{pyside.jpg}
	\caption{Biblioteka do interfejsu graficznego}
	\label{fig:pyside}
\end{figure}

Podsumowuj±c, projekt niesie ze sob± du¿± ilo¶æ wyzwañ i niewiadomych. Z tego wzglêdu wybrany zosta³ model iteracyjny i szereg elastycznych technologii wspieraj±cych takie podej¶cie. Wszystkie podjête decyzje organizacyjne i technologiczne maj± na celu zmniejszenie ryzyka i odpowiednie reagowanie na napotkane problemy. Umo¿liwia to okre¶lenie, ¿e projekt jako ca³o¶æ z du¿ym prawdopodobieñstwem zostanie wykonany, a wszelkie powa¿niejsze zagro¿enia ograniczone bêd± do poszczególnych funkcjonalno¶ci i modu³ów.

\subsection{Analiza zagro¿eñ}

Podczas tworzenia aplikacji do predykcji arytmii w tak ma³ym zespole istnieje wiele zagro¿eñ. Najistotniejsze z nich to:

\begin{itemize}
\item Brak wiedzy dziedzinowej - jako studenci informatyki nie posiadamy ¿adnej wiedzy z zakresu medycyny i chorób serca, nie wiemy szczegó³owo jak dzia³a ludzki organizm oraz jak pracuje narz±d, który pompuje krew w jego wnêtrzu. Mo¿e to bardzo utrudniæ pracê oraz prowadziæ do pewnych b³êdów w rozumowaniu.

\item Brak wystarczaj±cej ilo¶ci danych - potrzebujemy du¿ej ilo¶ci danych, aby program móg³ siê nauczyæ przewidywaæ arytmie. Dodatkowo dane te musz± byæ dok³adnie oznaczone, gdy¿ nie jeste¶my w stanie zrobiæ tego sami, a bardzo ciê¿ko o takie dane.

\item Niewystarczaj±ca skuteczno¶æ sieci neuronowej - mo¿e siê okazaæ ¿e nie jeste¶my w stanie uzyskaæ skuteczno¶ci, która by³aby satysfakcjonuj±ca, byæ mo¿e nie ma specjalnych prawid³owo¶ci, które pozwoli³yby przewidywaæ nieprawid³owo¶ci w pracy serca lub sieæ neuronowa nie poradzi sobie z tak skomplikowanym problemem.

\item Ró¿norodno¶æ typów arytmii - rodzajów arytmii jest wiele, nie wszystkie s± dok³adnie zbadane i opisane. Prawdopodobnie niektórych nie da siê przewidzieæ i nie bêdziemy mogli braæ wszystkich pod uwagê.
\end{itemize}

\section{\SectionTitleScope}
\label{sec:zakres-funkcjonalnosci}
\subsection{Charakterystyka u¿ytkowników systemu}

W naszym systemie wyró¿nia siê tylko jednego g³ównego u¿ytkownika. Korzysta on z programu na platformê Windows i ma dostêp do wszystkich funkcjonalno¶ci dostarczanych przez produkt.

\subsection{Wymagania funkcjonalne}

Wymagania funkcjonalne zosta³y przedstawione za pomoc± historyjek u¿ytkownika (ang. user stories), które okre¶laj± co u¿ytkownik chcê zrobiæ za pomoc± systemu i w jakim celu.

\begin{itemize}
	\item Chcê wy¶wietliæ zapisany wykres EKG ¿eby go przeanalizowaæ
	\item Chcê zobaczyæ wykres EKG aktualizowany w czasie rzeczywistym ¿eby na bie¿±co widzieæ jego zmiany i wyniki analizy
	\item Chcê zobaczyæ oznaczenia poszczególnych uderzeñ serca ¿eby lepiej zorientowaæ siê w wykresie i ³atwiej odnale¼æ interesuj±ce fragmenty
	\item Chcê zobaczyæ oznaczenia wykrytej arytmii serca ¿eby zlokalizowaæ poszczególne epizody oraz móc ³atwiej je przeanalizowaæ
	\item Chcê zobaczyæ podstawowe informacjê o poszczególnych arytmiach ¿eby lepiej zrozumieæ wyniki analizy i odpowiednio na nie zareagowaæ
	\item Chcê zobaczyæ wyniki predykcji arytmii w przysz³o¶ci ¿eby odpowiednio wcze¶niej zareagowaæ na spodziewane nieprawid³owo¶ci
\end{itemize}

\subsection{Wymagania niefunkcjonalne}

Wymagania aplikacji:

\begin{itemize}
	\item Musi dzia³aæ na systemach Windows
	\item Interfejs musi byæ intuicyjny, przejrzysty i dostarczaæ wszystkich wymaganych informacji
	\item Wy¶wietlane wykresy musz± byæ skalowalne
\end{itemize}

Wymagania technologiczne:

\begin{itemize}
	\item Musi istnieæ prosty sposób rozszerzania systemu o nowe formaty zapisu wykresów EKG
	\item System musi umo¿liwiaæ proste rozszerzanie o nowe metody analizy, w tym o ró¿ne algorytmy wykrywania i predykcji
\end{itemize}

\section{\SectionTitleRealizationAspects}
\label{sec:wybrane-aspekty-realizacji}
%TODO ma³o mamy kodu w tym rozdziale
%TODO chyba jakis diagram by siê jeszcze przyda³ :/
Projekt zosta³ podzielony na 3 g³ówne modu³y : 

\begin{itemize}
	\item interface - jest w pe³ni odpowiedzialny za interfejs graficzny
	\item model - zawiera wszystkie elementy dotycz±ce przetwarzania danych oraz predykcji
	\item experimental - znajduje siê w nim kod odpowiedzialny za testowanie i trenowanie ró¿nych konfiguracji sieci neuronowych
\end{itemize}

W odrêbnym module znajduj± siê wszystkie napisane przez nas testy.

\subsection{Interfejs}

Interfejs graficzny sk³ada siê na 4 g³ówne widoki: g³ówne menu, widok predykcji, widok przegl±dania wykresów EKG oraz widok z mikro-bibliotek± zawieraj±c± informacje o uwzglêdnionych typach arytmii. Ka¿dym widokiem zajmuje siê osobna klasa, a wszystkimi widokami zarz±dza manager. Poza g³ównymi widokami w zak³adce predykcji dostêpne s± 2 dodatkowe widoki otwierane w oddzielnym oknie: logów predykcji oraz wyboru modelu predykcji. Widoki zosta³y czê¶ciowo stworzone przy pomocy programu Qt Designer i zapisane w plikach formatu .ui. S± one ³adowane z tych plików, a nastêpnie odpowiednio modyfikowane ju¿ w kodzie. Fragment takiego pliku zosta³ przedstawiony na rysunku \ref{fig:ui_file}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{interface_class_diagram.png}
	\caption{Diagram klas modu³u interface}
	\label{fig:interface_diagram_class}
\end{figure}

\begin{figure}[H]
	\begin{lstlisting}[ caption={Kod managera widoków}]
	class ViewManager(QStackedWidget):
	
	    def __init__(self, *args, **kwargs):
	        super().__init__(*args, **kwargs)
	        self.menu = MenuWindow(self, load_ui('resources/menu.ui'))
	        self.predict = PredictWindow(self, load_ui('resources/predict.ui'), load_ui('resources/logs.ui'), load_ui('resources/models.ui'))
	        self.types = TypesWindow(self, load_ui('resources/types.ui'))
	        self.explore = ExploreWindow(self, load_ui('resources/explore.ui'))
	
	        self.addWidget(self.menu.window)
	        self.addWidget(self.predict.window)
	        self.addWidget(self.types.window)
	        self.addWidget(self.explore.window)
	
	        self.resize(1100, 700)
	        self.setWindowTitle("Arrhythmia prediction")
	        self.show()
	
	    def show_menu(self):
	        self.setCurrentWidget(self.menu.window)
	
	    def show_predict(self):
	        self.setCurrentWidget(self.predict.window)
	
	    def show_types(self):
	        self.setCurrentWidget(self.types.window)
	
	    def show_explore(self):
	        self.setCurrentWidget(self.explore.window)
	
	    def closeEvent(self, event):
	        self.explore.closeEvent()
	        self.predict.closeEvent()
	\end{lstlisting}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{ui_file.png}
	\caption{Przyk³adowy fragment pliku .ui}
	\label{fig:ui_file}
\end{figure}

\subsubsection{G³ówne menu}

Menu zawiera 4 przyciski i pozwala prze³±czaæ siê pomiêdzy g³ównymi widokami. Ka¿dy z tych widoków umo¿liwia powrót do g³ównego menu.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.3\linewidth]{menu.png}
	\caption{G³ówne menu programu}
	\label{fig:menu}
\end{figure}

\subsubsection{Widok predykcji}

Podstawowy i najwa¿niejszy widok w programie. Umo¿liwia on wczytanie danych EKG z pliku w formacie .dat(domy¶lny format bazy MIT-BIH z której korzystamy) poprzez wybranie go w eksploratorze plików.
 
Na podstawie wczytanych danych generowany jest wykres podgl±du przedstawiaj±cy 6 sekundowy fragment rekordu EKG. Wykres jest skalowany na osi Y do aktualnie wy¶wietlanych danych, tak aby by³y one zawsze dobrze widoczne. W prawym dolnym rogu tego wykresu znajduje siê mniejszy wykres, wraz z legend±, przedstawiaj±cy jak zmienia³y siê poszczególne warto¶ci predykcji na przestrzeni ostatnich 10 warto¶ci. 

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\linewidth]{plot.png}
	\caption{Wykres danych EKG wraz z wykresem zmian predykcji}
	\label{fig:plot}
\end{figure}

Nad wykresem znajduje siê pasek nawigacyjny umo¿liwiaj±cy:
\begin{itemize}
\item przeskok do wybranego fragmentu poprzez wpisanie warto¶ci pocz±tkowej wykresu w sekundach z dok³adno¶ci± do 2 cyfr dziesiêtnych, warto¶æ jest ograniczona do rozmiaru danych
\item przewijanie wykresu wstecz lub do przodu poprzez klikanie b±d¼ przytrzymanie odpowiedniego przycisku
\item odtwarzanie danych w przód co pozwala symulowaæ dzia³anie w czasie rzeczywistym
\end{itemize}

Dodatkowo po wczytaniu danych wy¶wietlana jest nazwa rekordu oraz maksymalna warto¶æ do której mo¿na przeskoczyæ. Odtwarzanie danych inicjowane jest przez odrêbny w±tek.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\linewidth]{navigation.png}
	\caption{Pasek do nawigacji po wykresie}
	\label{fig:navigation}
\end{figure}

Pod wykresem z prawej strony znajduje siê pasek wy¶wietlaj±cy warto¶ci, które na wyj¶ciu daje model predykcji dla aktualnych danych. Rozwa¿amy 3 typy arytmii o oznaczeniach: SVEB, VEB oraz F.
Predykcja równie¿ inicjowana jest w innym w±tku i odbywa siê co 1 sekundê w trakcie odtwarzania wykresu.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\linewidth]{output.png}
	\caption{Pasek warto¶ci predykcji}
	\label{fig:output}
\end{figure}

Pod wykresem z lewej strony znajduje siê przycisk, który umo¿liwia otworzenia okna wyboru modelu predykcji. Na li¶cie znajduj± siê dostêpne modele. Po wybraniu elementu z listy obok wy¶wietlany jest opis modelu. Zatwierdzenie przyciskiem OK powoduje ustawienie odpowiedniego modelu w programie.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{models.png}
	\caption{Okno wyboru modelu predykcji}
	\label{fig:models}
\end{figure}

Pod przyciskiem zmiany modelu znajduje siê przycisk do wy¶wietlania logów, który umo¿liwia otworzenie okna zawieraj±cego logi wszystkiego co siê do tej pory dzia³o w zak³adce dotycz±cej predykcji. W oknie mamy mo¿liwo¶æ wyczyszczenia dotychczasowej historii lub zapisania jej do pliku tekstowego.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{logs.png}
	\caption{Okno wy¶wietlaj±ce logi programu}
	\label{fig:logs}
\end{figure}

Ca³o¶æ prezentuje siê nastêpuj±co:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{prediction.png}
	\caption{Widok okna predykcji}
	\label{fig:prediction}
\end{figure}

\subsubsection{Przegl±danie danych}

W oknie tym mamy mo¿liwo¶æ przegl±dania bardziej szczegó³owych danych. Umo¿liwia wczytanie danych z plików wraz z informacjami na temat poszczególnych uderzeñ. Na podstawie danych generowany jest wykres na którym ka¿de uderzenie jest oznaczone w odpowiedni sposób. Nad wykresem znajduje siê pasek do nawigacji po wykresie taki sam jak w oknie predykcji.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{explore.png}
	\caption{Okno do przegl±dania oznaczonych danych}
	\label{fig:explore}
\end{figure}

\subsubsection{Dodatkowe informacje}

Jest to dodatkowe okno, bêd±ce ma³± bibliotek± rozwa¿anych przez nas typów arytmii. Z lewej strony mamy listê zawieraj±c± rodzaje nieprawid³owo¶ci. Po wybraniu elementu z listy po prawej stronie zostan± wy¶wietlone odpowiednie informacje. Dane wczytywane s± z plików tekstowych.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{types.png}
	\caption{Okno z informacjami na temat ró¿nych typów arytmii}
	\label{fig:types}
\end{figure}

\subsection{Model}

G³ównym zadaniem modu³u modelu w systemie jest dostarczenie funkcjonalno¶ci umo¿liwiaj±cej dokonywanie predykcji na podstawie wykresu EKG. W tym celu zdefiniowane zosta³o pojêcie silnika predykcji jako elementu dostarczaj±cego tak± funkcjonalno¶æ. Musi on dokonywaæ przetwarzania danych wej¶ciowych, takiego jak likwidacja szumów i normalizacja, oraz wykonywaæ predykcji. Predykcj± zwrócon± przez silnik bêdzie ci±g warto¶ci z przedzia³u od zera do jeden, o liczebno¶ci takiej samej jak ilo¶æ przewidywanych rodzajów arytmii. Ka¿da warto¶æ okre¶laæ bêdzie szansê na wyst±pienie danego rodzaju arytmii.

% FIXME Nie lubiê tego "jak zosta³o wspomniane" vv
Poniewa¿ jak wynik³o z analizy wykonalno¶ci projekt wymaga przetestowania du¿ej ilo¶ci sposobów dokonywania klasyfikacji, modu³ modelu musi dostarczaæ mo¿liwo¶æ stworzenia ró¿nych silników predykcji. W tym celu konieczna jest funkcjonalno¶æ do ³atwego tworzenia nowych silników. Dodatkowo model musi udostêpniaæ reszcie systemu mo¿liwo¶æ wyboru spo¶ród dostêpnych silników za pomoc± jednolitego interfejsu.

\subsubsection{Zasada dzia³ania}

W celu zrealizowania za³o¿onych wymagañ podjêta zosta³a decyzja o warstwowej budowie silnika predykcji. Przy takim za³o¿eniu modu³ modelu dostarcza gotowych warstw, z których zbudowane mog± zostaæ ró¿nego rodzaju silniki.  Na rysunku \ref{fig:model_example_flow}. przedstawiony zosta³ przyk³adowy schemat silnika predykcji ilustruj±cy przep³yw danych. Znajduj±ce siê na nim warstwy podane jako przyk³ad to:

\begin{description}
	\item[Fragmentacja danych] - z wej¶ciowych danych zostaje wydzielony fragment u¿ywany do predykcji. Rozmiar tego fragmentu odpowiada oknu na podstawie, którego wykonywana jest predykcja.
	\item[Zmniejszenie rozdzielczo¶ci] - czêstotliwo¶æ próbek zmniejszona jest w celu redukcji ilo¶ci cech i likwidacji szumów wysokich czêstotliwo¶ci. Przyk³adowo czêstotliwo¶æ mo¿e zostaæ zmniejszona z \SI{360}{\hertz} do \SI{60}{\hertz} przez usuniêcie wszystkich poza  co szóst± warto¶ci±.
	\item[Usuwanie niskich czêstotliwo¶ci] - za pomoc± transformaty Fouriera i jej odwrócenia likwidowane s± niskie czêstotliwo¶ci spowodowane miêdzy innymi przez oddech pacjenta. Przyk³adowo zlikwidowane mog± zostaæ czêstotliwo¶ci poni¿ej \SI{0.3}{\hertz} poprzez wyzerowanie odpowiednich warto¶ci po zastosowaniu szybkiej transformaty Fouriera.
	\item [Normalizacja danych] - przed wprowadzeniem danych do sieci neuronowej dane musz± zostaæ znormalizowane zgodnie z oczekiwan± normalizacj± dla sieci. Przyk³adowa funkcja normalizuj±ca to $f(x) = \frac{x - \overline{x}}{x_{\sigma}}$, gdzie $\overline{x}$ to ¶rednia warto¶ci $x$, a $x_{\sigma}$ to ich odchylenie standardowe.
	\item [Klasyfikacja] - sieæ neuronowa dokonuje klasyfikacji wieloklasowej i jako rezultat otrzymywane s± przewidywane szansê na wyst±pienie danej arytmii w przewidywanym oknie, okre¶lonym w trakcie trenowania sieci.
\end{description}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.4\linewidth]{model_example_flow.png}
	\caption{Schemat warstw w przyk³adowym silniku predykcji}
	\label{fig:model_example_flow}
\end{figure}

W celu umo¿liwienia takiej modu³owo¶ci dla budowy silników predykcji zdefiniowany zosta³ wspólny interfejs dla wszystkich warstw i zrealizowany jako abstrakcyjna klasa \emph{Layer}. Jej podstawowym za³o¿eniem jest przetwarzanie danych i przekazywanie ich do nastêpnych warstw w ci±gu. W tym celu posiada ona nastêpuj±ce metody:

\begin{itemize}
	\itemsep0em
	\item[] \emph{set\_next(Layer)} - ustawia nastêpny obiekt w silniku, do którego przekazywane bêd± wyniki obliczeñ
	\item[] \emph{push\_value(Numpy array)} - dostarcza obiekt na którym wykonane zostan± obliczenia, a ich wynik zostanie przekazany dalej
	\item[] \emph{compute(Numpy array): Numpy array} - abstrakcyjna metoda, która w klasach dziedzicz±cych powinna wykonywaæ zadane obliczenie i zwracaæ wynik
\end{itemize}

W trakcie tworzenia nowych silników predykcji stworzone zosta³y odpowiednie warstwy wewn±trz modelu, umo¿liwiaj±c ich ponowne wykorzystanie. Rysunek \ref{fig:pipes_uml} zawiera diagram klas przedstawiaj±cy relacjê miêdzy klasami implementuj±cymi  warstwy wewn±trz modelu, za¶ poni¿ej znajduj± siê ich szczegó³owe opisy.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.8\linewidth]{pipes_uml.png}
	\caption{Diagram klas dla warstw modelu}
	\label{fig:pipes_uml}
\end{figure}

\paragraph{IntervalSplitter} Pocz±tkowa warstwa, dokonuj±ca wyciêcia z wej¶ciowych danych okna zadanego rozmiaru. Na wej¶ciu otrzymuje ona ca³y dotychczasowy wykres EKG, z którego przekazywany dalej zostaje tylko ostatni fragment o rozmiarze oczekiwanym przez nastêpne warstwy i klasyfikator.

\paragraph{StandardNormalizer} Jest to warstwa dokonuj±ca normalizacji danych za pomoc± tzw. \emph{standaryzacji Z}. Wzór okre¶laj±cy ten rodzaj normalizacji to $f(x) = \frac{x - \overline{x}}{x_{\sigma}}$, gdzie $\overline{x}$ to warto¶æ ¶rednia, za¶ $x_\sigma$ to odchylenie standardowe. Dziêki zastosowaniu takiej normalizacji wyj¶ciowe warto¶ci posiadaj± ¶redni± równ± zero, za¶ odchylenie standardowe równe jeden. Ten rodzaj normalizacji jest szczególnie przydatny przy przetwarzaniu danych dla sieci neuronowych z warstwami zawieraj±cymi jako aktywacje funkcjê \emph{ReLU - Rectified Linear Unit}.

\paragraph{Downsampler} Warstwa odpowiadaj±ca za redukcjê czêstotliwo¶ci. Dziêki jej zastosowaniu jeste¶my w stanie znacz±co przy¶pieszyæ dzia³anie sieci neuronowej oraz zmniejszyæ wymiarowo¶æ danych. Oba te efekty pomagaj± zredukowaæ wp³yw \emph{przekleñstwa wymiaru} spowodowanego ogromn± ilo¶ci± cech w wej¶ciowym fragmencie EKG. Dodatkowo zmniejszenie ilo¶ci próbek pozwala usun±æ szum w wysokich czêstotliwo¶ciach spowodowany przez zak³ócenia elektroniczne lub niedoskona³o¶ci w trakcie analogowego zapisu i pó¼niejszej digitalizacji.
Rysunek \ref{fig:downsampling} prezentuje efekt redukcji czêstotliwo¶ci na przyk³adzie piêciosekundowego wycinka wykresu.

\begin{figure}[h!]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.6\linewidth]{downsampling.png}
	\caption{Redukcja czêstotliwo¶ci z \SI{360}{\hertz} (niebieski wykres) do \SI{60}{\hertz} (pomarañczowy wykres)}
	\label{fig:downsampling}
\end{figure}

\paragraph{NoiseRemover} Jest to warstwa usuwaj±ca szum niskich czêstotliwo¶ci, który spowodowany jest oddechem pacjenta, zmian± po³o¿enia i czynnikami zewnêtrznymi obecnymi w trakcie nagrywania zapisu. Operacja ta zosta³a zaimplementowana za pomoc± transformaty Fouriera. W pierwszej kolejno¶ci wej¶ciowy fragment przekszta³cany jest do domeny czêstotliwo¶ci, nastêpnie zerowane s± warto¶ci poni¿ej wybranej granicznej czêstotliwo¶ci. Po usuniêciu odpowiedniego przedzia³u wykonywana zostaje odwrotna transformata Fouriera, przywracaj±ca fragment do domeny czasu. Na rysunku \ref{fig:fft} widoczne jest dzia³anie tej warstwy na przyk³adzie fragmentu EKG, za¶ rysunek \ref{fig:fft_f} przedstawia ten sam fragment przedstawiony w dziedzinie czêstotliwo¶ci po zastosowaniu transformaty.

\begin{figure}[h!]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.6\linewidth]{noise_remove.png}
	\caption{Usuniêcie czêstotliwo¶ci poni¿ej \SI{0,5}{\hertz} za pomoc± transformaty Fouriera. Kolor niebieski - oryginalny fragment, kolor pomarañczowy - po wyciêciu niskich czêstotliwo¶ci.}
	\label{fig:fft}
\end{figure}

\begin{figure}[h!]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.6\linewidth]{fft_fdomain.png}
	\caption{Widok fragmentu wykresu EKG w dziedzinie czêstotliwo¶ci}
	\label{fig:fft_f}
\end{figure}

\paragraph{NNPredictor} Warstwa zawieraj±ca klasyfikator w postaci sieci neuronowej. Odpowiada ona za integracjê z bibliotek± Keras, w tym celu dokonuje zmiany kszta³tu danych wej¶ciowych do tego oczekiwanego przez sieæ. Wszystkie sieci u¿ywane w modelu s± wcze¶niej wytrenowane w module eksperymentów, warstwa ta wiêc wczytuje budowê sieci oraz wagi z pliku w formacie \emph{HDF5}.

\paragraph{FunctionLayer} Pomocnicza warstwa s³u¿±ca jedynie do integracji z pozosta³ymi elementami systemu. Nie przekszta³ca ona danych, a jej jedyn± funkcjonalno¶ci± jest wywo³anie zewnêtrznej funkcji, przekazuj±c jako argument rezultat poprzednich warstw.

\paragraph{Sequence} Pomocnicza warstwa tworz±ca abstrakcjê nad grup± innych warstw. W jej wypadku wykonanie obliczeñ jest równoznaczne wykonaniu obliczeñ przez wszystkie warstwy które w sobie zawiera. Dziêki jej zastosowaniu interfejs dla sekwencji warstw jest taki sam jak dla pojedynczej warstwy. Jest to przydatne poniewa¿ silnik wewn±trz modelu zdefiniowany jest jako ci±g warstw, dziêki takiej abstrakcji silnik wykorzystuje istniej±cy interfejs, co zwiêksza czytelno¶æ kodu i pomaga w integracji z reszt± systemu.

Dla pozosta³ych modu³ów wyznaczony zosta³ interfejs s³u¿±cy do wy¶wietlenia dostêpnych silników, stworzenia ¿±danego silnika oraz integracji jego funkcjonalno¶ci z obecn± struktur±. Poni¿ej znajduje siê szczegó³owy opis elementów tego interfejsu, za¶ na fragmencie 2. widoczny jest kod definiuj±cy interfejs oraz przyk³adowy silnik predykcji.

\begin{itemize}
	\itemsep0em
	\item[] \emph{PredictionEngine} - klasa definiuj±ca silnik predykcji, zawiera jego nazwê, opis i warstwy z których siê sk³ada
	\item[] \emph{engines} - lista dostêpnych silników predykcji
	\item[] \emph{create\_prediction\_engine(PredictionEngine)} - pomocnicza funkcja buduj±ca silnik, wczytuje klasyfikator oraz ³±czy ze sob± warstwy
	\item[] \emph{FunctionLayer} - klasa umo¿liwiaj±ca do³±czenie na koñcu silnika wywo³ania funkcji z wynikiem predykcji
\end{itemize}

\begin{lstlisting}[float=h, style=custompy, caption=Interfejsu modelu i przyk³ad wykorzystania]
# Przyk³ad definicji silnika:
engines = [
    PredictionEngine('convolutional', [
        IntervalSplitter(360*60*5, 360),
        Downsampler(360, 60),
        NoiseRemover(60, 0.5),
        StandardNormalizer(),
        networks[0].load()]),
    # ...
]


def create_prediction_engine(engine):
    return engine.build()

# Stworzenie silnika predykcji:
p_engine = create_prediction_engine(engines[0])

# Przyk³ad integracji - tutaj wypisanie wyników
p_engine.set_next(FunctionLayer(print))

values = # Warto¶ci fragmentu EKG

# Wywo³anie obliczeñ:
p_engine.push_value(values)
\end{lstlisting}

\subsubsection{Silniki predykcji}

Model udostêpnia ró¿ne silniki predykcji ró¿ni±ce siê struktur±, algorytmem, rozmiarami przedzia³ów danych i skuteczno¶ci±. Silniki zosta³y podzielone na dwie grupy w zale¿no¶ci od budowy sieci neuronowej, któr± wykorzystuj±. S± to silniki gêste i konwolucyjne. Poni¿ej znajduj± siê ogólne opisy ka¿dej grupy, budowa udostêpnianych silników, wykorzystywanych sieci oraz ich skuteczno¶æ. Opis metodologii testowania, dok³adniejsze rezultaty testów oraz wszystkie wypróbowane architektury znajduj± siê w dziale \ref{sec:experimental} - Eksperymenty.

\paragraph{Gêste}

Jako pierwsze utworzone zosta³y silniki predykcji oparte na sieciach neuronowych zbudowanych z gêstych warstw (ang. \emph{dense}). W warstwach tych wszystkie warto¶ci wyj¶ciowe obliczane s± na podstawie wszystkich danych wej¶ciowych. Matematycznie warstwa gêsta zdefiniowana jest jako:
$$
out = f_a(A \cdot in + bias)
$$
, gdzie $f_a$ to funkcja aktywacji, $A, bias$ to wewnêtrzne warto¶ci warstwy aktualizowane w trakcie uczenia, $in, out$ to kolejno wej¶cie i wyj¶cie gêstej warstwy. 

W warstwie gêstej neurony \emph{³±cz±} ka¿d± warto¶æ wej¶ciow± z ka¿d± warto¶ci± wyj¶ciow±, z tego powodu ilo¶æ parametrów w sieci zbudowanej z takich warstw ro¶nie bardzo szybko wraz ze wzrostem z³o¿ono¶ci i wymiarowo¶ci danych. Z tego powodu sieæ taka jest bardzo podatna na przetrenowania, to znaczy wyuczenie siê zbioru treningowego zamiast zale¿no¶ci jakie reprezentuje. Dodatkowo sieæ taka traktuje w ten sam sposób zale¿no¶æ miêdzy odleg³ymi warto¶ciami w danych wej¶ciowych, a warto¶ciami s±siednimi. Z tego powodu sieæ ta niezbyt dobrze nadaje siê do klasyfikacji wykresów zale¿nych od czasu tak jak w naszym przypadku.

\begin{table}[h]
	\centering
\begin{tabular}{l|lllll}
	Nazwa & Wej¶cie & Okres predykcji & Czêstotliwo¶æ & Redukcja szumów & Skuteczno¶æ \\ \hline
	dense1 & 5 minut & 2 minuty & \SI{60}{\hertz} & < \SI{1}{\hertz} & \SI{69,00}{\percent} \\
	dense2 & 3 minuty & 1 minuta & \SI{60}{\hertz} & < \SI{1}{\hertz} & \SI{73,48}{\percent}
\end{tabular}
\caption{Silniki predykcji oparte o gêste sieci neuronowe}
\label{tab:dense_engines}
\end{table}

\begin{table}[h]
	\centering
\begin{tabular}{l|ll}
	Warstwa      & Parametry             & Aktywacja \\ \hline
	Dense        & units = 100           & relu         \\
	Dense        & units = 200           & relu         \\
	Dense        & units = 100           & relu         \\
	Dense        & units = 3             & sigmoid
\end{tabular}
\caption{Warstwy w sieci gêstej dla silników \emph{dense1} i \emph{dense2}}
\label{tab:dense1}
\end{table}

\paragraph{Konwolucyjne}

W konwolucyjnych silnikach predykcji g³ównym za³o¿eniem by³o wykorzystanie konwolucyjnej sieci neuronowej. Spowodowane by³o to bardzo s³abymi wynikami dla gêstych sieci z powodu przetrenowania oraz sekwencyjn± struktur± danych. Sieci konwolucyjne pozwalaj± bardzo dobrze klasyfikowaæ dane, gdzie wa¿ne jest wzajemne po³o¿enie cech, czyli w naszym przypadku odleg³o¶æ miêdzy warto¶ciami na wykresie EKG. Innym przypadkiem przydatno¶ci takiej reprezentacji jest klasyfikacja obrazów, gdzie bardziej istotne s± s±siednie piksele ni¿ te znajduj±ce siê na osobnych koñcach.

G³ównymi czê¶ciami sk³adowymi w konwolucyjnych sieciach neuronowych s± warstwy wykonuj±ce konwolucjê oraz warstwy redukuj±ce ich rozmiar przez tzw. \emph{pooling}. W kontek¶cie przetwarzania danych EKG, wykonywali¶my konwolucji w jednym wymiarze. Polega ona na sumie iloczynów warto¶ci filtra i fragmentu wej¶ciowych danych. Wyj¶ciowa sekwencja jest ci±giem wyników takich operacji dla kolejnych fragmentów wej¶cia. Ilustracja dzia³ania konwolucji znajduje siê na rysunku \ref{fig:convolution}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{convolution.png}
	\caption{Dzia³anie konwolucji w jednym wymiarze, dla rozmiaru filtra 3 i przesuniêcia 1}
	\label{fig:convolution}
\end{figure}

Dodatkowo pojedyncza warstwa konwolucyjna mo¿e sk³adaæ siê z dowolnej ilo¶ci filtrów, wyj¶ciem jest wiêc ci±g sekwencji. W celu zmniejszenia ilo¶ci wyj¶ciowych danych jako nastêpn± warstwê stosuje siê \emph{pooling}.
W naszym wypadku wykorzystali¶my warstwy \emph{max-poolingu}, które wybieraj± najwiêksz± warto¶æ z zadanego przedzia³u i podobnie jak konwolucje produkuj± ci±g warto¶ci dla przesuniêtych przedzia³ów. Dzia³anie tej operacji ilustruje rysunek \ref{fig:max_pool}.

\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.4\linewidth]{max_pool.png}
	\caption{Dzia³anie operacji 'max-pool' w jednym wymiarze, dla przedzia³u 3 i przesuniêcia 3}
	\label{fig:max_pool}
\end{figure}

\begin{table}[h]
	\centering
\begin{tabular}{l|lllll}
	Nazwa & Wej¶cie & Okres predykcji & Czêstotliwo¶æ & Redukcja szumów & Skuteczno¶æ \\ \hline
	conv1 & 5 minut & 2 minuty & \SI{60}{\hertz} & < \SI{1}{\hertz} & \SI{84.21}{\percent} \\
	conv2 & 3 minuty & 1 minuta & \SI{60}{\hertz} & < \SI{1}{\hertz} & \SI{85.06}{\percent}
\end{tabular}
\caption{Silniki predykcji oparte o gêste sieci neuronowe}
\label{tab:conv_engines}
\end{table}

\begin{table}[h!]
	\centering
\begin{tabular}{l|ll}
	Warstwa      & Parametry                       & Aktywacja \\ \hline
	Reshape      & -                               & -         \\
	Conv1D       & kernels = 16, filter\_size = 16 & relu \\
	MaxPooling1D & pool\_size = 8                  & - \\
	Conv1D       & kernels = 8, filter\_size = 16  & relu \\
	MaxPooling1D & pool\_size = 8                  & - \\
	Conv1D       & kernels = 8, filter\_size = 16  & relu \\
	MaxPooling1D & pool\_size = 8                  & - \\
	Flatten      & -                               & - \\
	Dense        & units = 3                       & sigmoid
\end{tabular}
\caption{Warstwy w sieci konwolucyjnej dla silnika \emph{conv1}}
\label{tab:conv1}
\end{table}

\begin{table}[h!]
	\centering
\begin{tabular}{l|ll}
	Warstwa      & Parametry                       & Aktywacja \\ \hline
	Reshape      & -                               & -         \\
	Conv1D       & kernels = 32, filter\_size = 16 & relu \\
	MaxPooling1D & pool\_size = 16                 & - \\
	Conv1D       & kernels = 16, filter\_size = 16 & relu \\
	MaxPooling1D & pool\_size = 16                 & - \\
	Flatten      & -                               & - \\
	Dense        & units = 3                       & sigmoid
\end{tabular}
\caption{Warstwy w sieci konwolucyjnej dla silnika \emph{conv2}}
\label{tab:conv2}
\end{table}

\subsection{Eksperymenty} \label{sec:experimental}

\subsubsection{Baza treningowa}

Jako bazê treningow± wykorzystali¶my ogólnodostêpn± bazê danych EKG z oznaczonymi danymi - MIT-BIH Arrhythmia Database \cite{Moody2001TheIO}\cite{physionet}. Baza ta zawiera 48 pó³-godzinnych, 2 kana³owych zapisów EKG. 23 rekordy zosta³y wybrane losowo ze zbioru 4000 24-godzinnych nagrañ. Pozosta³e 25 rekordów zosta³ wybranych z tego samego zbioru, jednak zawieraj±cych rzadsze, ale równie¿ klinicznie istotne przypadki arytmii.

Rekordy zosta³y zapisane z czêstotliwo¶ci± 360 próbek na sekundê, dla ka¿dego z kana³ów z 11 bitow± rozdzielczo¶ci± w zakresie \SI{10}{\milli\volt}. Ka¿de nagranie zosta³o niezale¿nie oznaczone przez 2 lub wiêcej kardiologów. Sprzeczno¶ci zosta³y rozwi±zane w taki sposób aby uzyskaæ czytelne komputerowo referencje dla ka¿dego uderzenia znajduj±cego siê w bazie. W przybli¿eniu jest to 110,00 oznaczeñ w ca³ej bazie.

Dla ka¿dego rekordu w bazie znajduj± siê 3 pliki:

\begin{itemize}
	\item plik .dat zawieraj±cy warto¶ci kolejnych próbek
	\item plik .atr zawieraj±cy oznaczenie typu arytmii oraz miejsce jej wyst±pienia na przebiegu EKG
	\item plik .hea zawieraj±cy nag³ówek opisuj±cy format danych
\end{itemize}
%TODO KD dodajemy w ¿ród³ach wfdb?
Do pobrania danych z sieci wykorzystali¶my gotow± bibliotekê wfdb napisan± w jêzyku Python, która umo¿liwia w bardzo prosty sposób pobranie ca³ej bazy.

\subsubsection{Typy arytmii}

Baza MIT-BIH zawiera dane z oznaczeniami 15 ró¿nych typów uderzeñ serca. Jest to zbyt du¿a ilo¶æ, aby uwzglêdniaæ je wszystkie. Postanowili¶my wiêc zastosowaæ standard AAMI i przekszta³ciæ dane w odpowiedni sposób.

Zawêzi³o to zbiór typów uderzeñ do 5:
%TODO moza jakies krótkie opisy uderzeñ
\begin{itemize}
	\item N - Normal beat
	\item SVEB- Supraventricular ectopic beat
	\item VEB - Ventricular ectopic beat
	\item F - Fusion
	\item Q - Unknown beat
\end{itemize}

\begin{lstlisting}[float=h!, caption={Kod mapuj±cy oznaczenia z bazy MIT-BIH do standardu AAMI}]
mapping = {
	BeatType('N', 'Normal beat'): {'N', 'L', 'R'},
	BeatType('SVEB', 'Supraventricular ectopic beat'): {'e', 'j', 'A', 'a', 'J', 'S'},
	BeatType('VEB', 'Ventricular ectopic beat'): {'V', 'E'},
	BeatType('F', 'Fusion'): {'F'},
	BeatType('Q', 'Unknown beat'): {'/', 'f', 'Q'}
	}

def mit_to_aami(symbol):
	for key, value in mapping.items():
		if symbol in value:
			return key
	return None
	
\end{lstlisting}
 
\subsubsection{Podzia³ danych}

W celu uproszczenia predykcji z zapisów wybrali¶my tylko jeden kana³, który powtarza³ siê we wszystkich przypadkach - \emph{MLII}.
Aby w pe³ni wykorzystaæ dane znajduj±ce siê w bazie, ka¿dy rekord jest dzielony na fragmenty o okre¶lonej d³ugo¶ci, wybierane co okre¶lony krok czasowy. W ten sposób otrzymujemy wiele unikalnych fragmentów stanowi±cych podci±gi ca³ego rekordu.

\begin{lstlisting}[float=h!, caption={Funkcja dziel±ca rekordy na fragmenty}]
def slice_records(records, pred_len, post_len, increment=360*60, check_pred=True):
    for record in records:
        for start in range(0, len(record[0]) - pred_len - post_len, increment):
            pred_end = start + pred_len
            post_end = pred_end + post_len
             pred = record[0][start:pred_end]
            post = record[0][pred_end:post_end]
             pred_inds = np.logical_and(start <= record[1], record[1] < pred_end)
            post_inds = np.logical_and(pred_end <= record[1], record[1] < post_end)
            if check_pred:
                pred_labels = record[2][pred_inds]
                if np.all(pred_labels == 'N'):
                    pred_result = pred, record[1][pred_inds], pred_labels
                    post_result = post, record[1][post_inds], record[2][post_inds]
                    yield pred_result, post_result
            else:
                pred_result = pred, record[1][pred_inds], record[2][pred_inds]
                post_result = post, record[1][post_inds], record[2][post_inds]
                yield pred_result, post_result

\end{lstlisting}

Dziel±c dane na treningowe i testowe zdecydowali¶my siê zastosowaæ K-krotn± walidacje krzy¿ow± (z ang. K-fold cross-validation). Polega ona na tym ¿e oryginalny zbiór jest dzielony na K podzbiorów. Nastêpnie ka¿dy z nich jest brany jako zbiór testowy, a pozosta³e razem stanowi± zbiór ucz±cy. Odbywa siê wiêc K iteracji, których wyniki s± nastêpnie u¶redniane w celu uzyskania ostatecznego wyniku. W naszym wypadku jako parametr $K$ oraz ilo¶æ iteracji wybrali¶my warto¶æ 5.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{kfold.png}
	\caption{Wizualizacja dzia³ania K-fold dla K=10 \cite{kfold}}
	\label{fig:kfold}
\end{figure}
%TODO KD czy to jest dobrze zcytowany obrazek?
%¿ród³o: http://karlrosaen.com/ml/learning-log/2016-06-20/
%licencja: https://creativecommons.org/licenses/by-nc/4.0/

\subsubsection{Metodologia oceny skuteczno¶ci}

Klasyfikujemy cztery klasy uderzeñ serca:
\begin{itemize}
\item Nadkomorowy skurcz dodatkowy (SVEB)
\item Komorowy skurcz dodatkowy (VEB)
\item Uderzenia po³±czone (F)

\end{itemize}

W celu oceny skuteczno¶ci naszych predykcji konieczne by³o wybranie odpowiednich metryk, które dawa³aby informacjê o jako¶ci testowanych sieci. Poniewa¿ rozwa¿any problem sprowadza siê do klasyfikacji wieloklasowej, niemo¿liwe by³o wykorzystanie gotowych metryk dostêpnych w bibliotece Keras. Spo¶ród sposobów oceny modeli dla klasyfikacji wieloklasowej \cite{mlpsurvey2010} do eksperymentów wybrali¶my nastêpuj±ce:

\begin{description}
\item [Skuteczno¶æ (\emph{Accuracy})] W wypadku jednej klasy jest to stosunek ilo¶ci poprawnie sklasyfikowanych przypadków do liczby wszystkich przypadków. Dla klasyfikacji wieloklasowej skuteczno¶æ zdefiniowana jest jako ¶rednia skuteczno¶ci klasyfikacji dla poszczególnych klas.

\item [B³±d ¶redniokwadratowy (\emph{Mean Squared Error})] B³±d dla pojedynczej próbki jest to odleg³o¶æ miêdzy warto¶ci± oczekiwan±, a przewidywan±. Metryka ta jest równa ¶redniej kwadratów tych b³êdów dla wszystkich próbek. Ma to efekt taki, ¿e na b³±d mocniej wp³ywaj± du¿e ró¿nice miêdzy warto¶ciami. Dla idealnego klasyfikatora b³±d by³by równy jeden.

\item [Precyzja (\emph{Precision})] Precyzja dla jednej klasy to stosunek poprawnie sklasyfikowanych wyst±pieñ do wszystkich przewidzianych wyst±pieñ. Dla klasyfikacji wieloklasowej jest to ¶rednia precyzji jednoklasowej ze wszystkich klas. W naszym wypadku jest to ¶rednia stosunku poprawnie przewidzianych arytmii do wszystkich przewidzianych wyst±pieñ.

\item [Czu³o¶æ (\emph{Recall})] Czu³o¶æ dla jednej klasy to stosunek poprawnie przewidzianych pozytywów do ilo¶ci pozytywnych próbek. Podobnie jak w przypadku czu³o¶ci, dla klasyfikacji wieloklasowej jest to ¶rednia metryki jednoklasowej ze wszystkich klas. Dla naszego problemu jest to ¶rednia stosunku poprawnie przewidzianych wyst±pieñ do wszystkich arytmii.

\item [Miara $F_1$ (\emph{$F_1$-Measure})] Jest to ¶rednia harmoniczna czu³o¶ci i precyzji, dziêki czemu jej warto¶æ dok³adniej odzwierciedla jako¶æ klasyfikatora ni¿ osobne metryki.
%TODO opisac funkcje loss
\end{description}

Funkcja straty któr± wykorzystujemy to \textbf{Binary Cross-entropy}. Mierzy ona wydajno¶æ modelu klasyfikacji, która na wyj¶ciu daje warto¶ci prawdopodobieñstwa pomiêdzy 0 i 1. Jej warto¶æ ro¶nie wraz z rosn±c± ró¿nic± miêdzy warto¶ci± przewidzian± a rzeczywist±. Dla idealnego modelu warto¶æ tej funkcji by³aby równa 0.

\subsubsection{Wyniki dla ró¿nych modeli}

Wszystkie eksperymenty przeprowadzali¶my wykorzystuj±c notatniki Jupter. Pozwoli³y nam one na bie¿±co wizualizowaæ rezultaty naszych modeli dziêki wy¶wietlaniu wykresów straty, dok³adno¶ci i innych metryk. Dodatkowo mo¿liwe by³o podejrzenie rezultatów i dyskusja nad nimi bez konieczno¶ci uruchamiania czasoch³onnego trenowania, tylko po to by podejrzeæ wyniki. Równie¿ z poziomu notatników zapisywali¶my gotowe sieci neuronowe do wykorzystania w modelu.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{jupyter.png}
	\caption{Widok z notebooka Jupytera}
	\label{fig:jupyter}
\end{figure}

\paragraph{Sieci gêste} Wyniki dla sieci gêstych sk³adaj±cych siê z kilku warstw ukrytych o ró¿nych rozmiarach oraz warstwy wyj¶ciowej.

Sieæ gêsta z 3 warstwami ukrytymi o szeroko¶ciach 10, 50 i 10.

\begin{lstlisting}[float=h!, style=result, caption={Wyniki sieci gêstej o rozmiarach warstw 10, 50, 10}]
loss: 0.6130 (+/-0.0159), binary_accuracy: 0.6704 (+/-0.0213), mean_squared_error: 0.2102 (+/-0.0071), precision: 0.4789 (+/-0.0475), recall: 0.3681 (+/-0.0560), fmeasure: 0.3917 (+/-0.0182)
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{dense_10_50_10_loss.png}
	\caption{Wykres straty dla sieci gêstej o rozmiarach warstw 10, 50, 10}
	\label{fig:dense_10_50_10_loss}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{dense_10_50_10_acc.png}
	\caption{Wykres dok³adno¶ci dla sieci gêstej o rozmiarach warstw 10, 50, 10}
	\label{fig:dense_10_50_10_acc}
\end{figure}

Sieæ gêsta z 2 warstwami ukrytymi o szeroko¶ci 100 i 100.

\begin{lstlisting}[float=h!, style=result, caption={Wyniki sieci gêstej o rozmiarach warstw 100, 100}]
loss: 0.6172 (+/-0.0219), binary_accuracy: 0.6820 (+/-0.0200), mean_squared_error: 0.2086 (+/-0.0084), precision: 0.4631 (+/-0.0315), recall: 0.3754 (+/-0.0372), fmeasure: 0.3973 (+/-0.0376)
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{dense_100_100_loss.png}
	\caption{Wykres straty dla sieci gêstej o rozmiarach warstw 100, 100}
	\label{fig:dense_100_100_loss}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{dense_100_100_acc.png}
	\caption{Wykres dok³adno¶ci dla sieci gêstej o rozmiarach warstw 100, 100}
	\label{fig:dense_100_100_acc}
\end{figure}

Sieæ gêsta z 3 warstwami  ukrytymi o szeroko¶ciach 100, 200 i 100.

\begin{lstlisting}[float=h!, style=result, caption={Wyniki sieci gêstej o rozmiarach warstw 100, 200, 100}]
loss: 0.5799 (+/-0.0133), binary_accuracy: 0.6900 (+/-0.0091), mean_squared_error: 0.1969 (+/-0.0045), precision: 0.4926 (+/-0.0249), recall: 0.3370 (+/-0.0282), fmeasure: 0.3836 (+/-0.0115)
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{dense_100_200_100_loss.png}
	\caption{Wykres straty dla sieci gêstej o rozmiarach warstw 100, 200, 100}
	\label{fig:dense_100_200_100_loss}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{dense_100_200_100_acc.png}
	\caption{Wykres dok³adno¶ci dla sieci gêstej o rozmiarach warstw 100, 200, 100}
	\label{fig:dense_100_200_100_acc}
\end{figure}

\paragraph{Sieci konwolucyjne} W naszym projekcie sieci konwolucyjne, które testowali¶my zbudowane by³y z naprzemiennych warstw konwolucji jednowymiarowej oraz warstw 'max-poolingu'. We wszystkich warstwach konwolucyjnych jako aktywacjê wykorzystali¶my funkcjê \emph{ReLU}. Dodatkowo na koñcu znajdowa³a siê gêsta warstwa wyj¶ciowa z aktywacj± sigmoidaln±. W ramach eksperymentów zmieniali¶my rozmiar warstw 'max-pool' oraz ilo¶æ filtrów i ich rozmiar w poszczególnych warstwach konwolucyjnych.

Poni¿ej prezentujemy wyniki eksperymentów dla sieci przy wymiarze danych wej¶ciowych 5 minut i przedziale predykcji 2 minuty. Przed wej¶ciem do sieci zastosowali¶my redukcjê czêstotliwo¶ci do \SI{60}{\hertz}, usuniêcie szumów poni¿ej \SI{1}{\hertz} oraz normalizacjê.

\begin{table}[h]
\centering
\begin{tabular}{p{5em}p{4em}p{3em}lllll}
Rozmiar 'poolingu' & Rozmiar filtrów & Ilo¶ci filtrów & Skuteczno¶æ & MSE & Precyzja & Czu³o¶æ & Miara $F_1$ \\ \hline
16 & 16 & 4, 16    & \SI{83.82}{\percent} & $0.1174$ & $0.8013$ & $0.6223$ & $0.6768$ \\
16 & 16 & 32, 16   & \SI{82.94}{\percent} & $0.1178$ & $0.7980$ & $0.6589$ & $0.6813$ \\
8  & 16 & 16, 8, 4 & \SI{84.21}{\percent} & $0.1134$ & $0.8229$ & $0.5770$ & $0.6546$
\end{tabular}
\end{table}

\begin{lstlisting}[float=h!, style=result, caption={Wyniki sieci konwolucyjnej z parametrami: pool=16, warstwy=(4, 16), (16, 16)}]
loss: 0.3686 (+/-0.0243), binary_accuracy: 0.8382 (+/-0.0234), mean_squared_error: 0.1174 (+/-0.0095), precision: 0.8013 (+/-0.0821), recall: 0.6223 (+/-0.1151), fmeasure: 0.6768 (+/-0.0526)
\end{lstlisting}

\begin{figure}[H]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.7\linewidth]{conv_16_4_loss.png}
	\caption{Wykres straty dla sieci konwolucyjnej z parametrami: pool=16, warstwy=[(4, 16), (16, 16)]}
	\label{fig:conv_16_4_loss}
\end{figure}
\begin{figure}[H]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.7\linewidth]{conv_16_4_acc.png}
	\caption{Wykres dok³adno¶ci dla sieci konwolucyjnej z parametrami: pool=16, warstwy=[(4, 16), (16, 16)]}
	\label{fig:conv_16_4_acc}
\end{figure}

Sieæ konwolucyjna pool=16, warstwy=[(32, 16), (16, 16)]

\begin{lstlisting}[float=h!, style=result, caption={Wyniki sieci konwolucyjnej z parametrami: pool=16, warstwy=(32, 16), (16, 16)}]
loss: 0.3688 (+/-0.0522), binary_accuracy: 0.8294 (+/-0.0351), mean_squared_error: 0.1178 (+/-0.0204), precision: 0.7980 (+/-0.1436), recall: 0.6589 (+/-0.1287), fmeasure: 0.6813 (+/-0.0438)
\end{lstlisting}

\begin{figure}[H]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.7\linewidth]{conv_16_32_loss.png}
	\caption{Wykres straty dla sieci konwolucyjnej z parametrami: pool=16, warstwy=[(32, 16), (16, 16)]}
	\label{fig:conv_16_32_loss}
\end{figure}
\begin{figure}[H]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.7\linewidth]{conv_16_32_acc.png}
	\caption{Wykres dok³adno¶ci dla sieci konwolucyjnej z parametrami: pool=16, warstwy=[(32, 16), (16, 16)]}
	\label{fig:conv_16_32_acc}
\end{figure}

Sieæ konwolucyjna pool=8, warstwy=[(16, 16), (8, 16), (4, 16)]

\begin{lstlisting}[float=h!, style=result, caption={Wyniki sieci konwolucyjnej z parametrami: pool=8, warstwy=(16, 16), (8, 16), (4, 16)}]
loss: 0.3577 (+/-0.0553), binary_accuracy: 0.8421 (+/-0.0366), mean_squared_error: 0.1134 (+/-0.0218), precision: 0.8229 (+/-0.0607), recall: 0.5770 (+/-0.0925), fmeasure: 0.6546 (+/-0.0808)
\end{lstlisting}

\begin{figure}[H]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.7\linewidth]{conv_8_16_loss.png}
	\caption{Wykres straty dla sieci konwolucyjnej z parametrami: pool=8, warstwy=[(16, 16), (8, 16), (4, 16)]}
	\label{fig:conv_8_16_loss}
\end{figure}
\begin{figure}[H]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.7\linewidth]{conv_8_16_acc.png}
	\caption{Wykres dok³adno¶ci dla sieci konwolucyjnej z parametrami: pool=8, warstwy[(16, 16), (8, 16), (4, 16)]}
	\label{fig:conv_8_16_acc}
\end{figure}

%TODO podsumowanie wyników !!!
\subsection{Testy}

Wraz z rozrastaniem siê projektu starali¶my siê równolegle pisaæ testy dla nowo powstaj±cych elementów. Stworzyli¶my trzy zestawy testów: dla interfejsu, dla wewnêtrznych struktur modelu oraz osobny zestaw dla warstw udostêpnianych przez model. W celu zrealizowania walidacji wybrali¶my bibliotekê Pytest. Udostêpnia bardzo prosty i nieinwazyjny model pisania testów poprzez natywne funkcje, oraz posiada du¿± ilo¶æ wtyczek rozszerzaj±cych jej mo¿liwo¶ci, miêdzy innymi o funkcjonalno¶æ testowania interfejsów Qt.

Dodatkowo w projekcie zastosowali¶my praktykê ci±g³ej integracji (\emph{Continuous Integration}), ca³y zestaw testów by³ automatycznie uruchamiany przed i po ka¿dej zmianie, co równie¿ po¶rednio obejmowa³o testowanie instalacji i pobierania zale¿no¶ci dla aplikacji. Co wiêcej do testów automatycznych dodali¶my równie¿ sprawdzanie jako¶ci kodu poprzez zgodno¶æ ze wskazówkami zawartymi w PEP-8\cite{pep8}. Wszystko to poparte by³o wzajemn± recenzj± kodu przez autorów.

Dziêki takiemu podej¶ciu do poprawno¶ci naszej pracy byli¶my w stanie znacz±co poprawiæ jako¶æ naszego kodu oraz zmniejszyæ ilo¶æ b³êdów. B³êdy natomiast, które dostawa³y siê do aplikacji, by³y znacznie ³atwiejsze do znalezienia oraz naprawienia. Dodatkowo dziêki recenzj± przed ka¿d± zmian±, oboje znali¶my nasz wzajemny postêp prac oraz ca³o¶ciow± strukturê aplikacji. Wszystko to znacz±co zmniejszy³o czas spêdzony nad poprawianiem b³êdów, rozszerzaniem funkcjonalno¶ci oraz integracj± modu³ów.

\begin{lstlisting}[float=h!, caption={Przyk³adowy test interfejsu}]
def test_loading_and_plotting_predict(qtbot, manager):
    # Simple test for loading and plotting in predict window

    predict = manager.predict
    predict.load_plot_from_file("100.dat")
    predict.set_new_plot()

    assert predict.start == 0
    assert predict.start_line.text() == "0"
    assert predict.sig_len > 0
    assert predict.figure is not None
\end{lstlisting}

\begin{lstlisting}[float=h!, caption={Przyk³adowy test normalizacji}]
def test_standard_normalizer():
    # Given:
    # Create random sequence of uniform values from interval [0, 1)
    length = 100
    random_uniform = np.random.rand(length)
    normalizer = StandardNormalizer()  # Create the normalizer to test
    # Helper pipe to save the result
    result = None

    def set_result(v):
        nonlocal result
        result = v

    endp = FunctionLayer(set_result)
    normalizer.set_next(endp)  # Connect normalizer to ending pipe
    # When:
    normalizer.push_value(random_uniform)
    # Then:
    # Length of output sequence should be the same as input sequence
    assert len(result) == length
    # Mean should be zero
    assert abs(result.mean()) < epsilon  
    # Standard deviation should be zero
    assert abs(result.std() - 1.0) < epsilon
\end{lstlisting}

\section{\SectionTitleWorkOrganization}
\label{sec:organizacja-pracy}

\subsection{Charakterystyka projektu}

Zaproponowany temat projektu obejmowa³ zagadnienia z dziedziny nie powi±zanej z naszym kierunkiem studiów. Praca ma te¿ w pewnym stopniu charakter eksperymentalny, gdy¿ nie jest udokumentowane w jakim stopniu metody uczenia maszynowego maj± zastosowanie w predykcji arytmii serca na podstawie samego wykresu EKG. Wiele czasu po¶wiêcili¶my na testowanie skuteczno¶ci predykcji ró¿nych modeli sieci. Dodatkowo musieli¶my te¿ zbadaæ wp³yw parametrów danych wej¶ciowych, takich jak d³ugo¶æ fragmentu EKG na wej¶ciu, okres w którym staramy siê przewidzieæ wyst±pienie arytmii, jak i stopieñ redukcji szumów czy interpolacja danych do mniejszych czêstotliwo¶ci. 

Dodatkowo aby predykcja by³a mo¿liwa musimy mieæ oznaczone dane treningowe, na których bêdziemy mogli trenowaæ nasz± sieæ. Jednak ciê¿ko znale¼æ ogólnodostêpne dane, które spe³nia³yby to wymaganie. Wykorzystali¶my wiêc jedynie bazê, któr± zaproponowa³ nam promotor. Ze wzglêdu na niedu¿y rozmiar danych, starali¶my siê w pe³ni wykorzystaæ u¿ywan± przez nas bazê danych.

\subsection{Struktura zespo³u i role}

W sk³ad naszego zespo³u wchodzi³o dwóch studentów Informatyki. Pracê nad systemem podzielili¶my na zadania, które starali¶my siê równo podzieliæ miêdzy cz³onkami zespo³u. Dodatkowo przy dzieleniu siê prac± brali¶my pod uwagê umiejêtno¶ci, zainteresowania i do¶wiadczenie. Nad szczególnymi i kluczowymi elementami projektu pracowali¶my wspólnie.

\begin{itemize}
%TODO zaktualizowaæ
	\item \textbf{Tomasz Nizio}	
	
	Implementacja redukcja szumów o niskich czêstotliwo¶ciach przy pomocy FFT, projekt ca³ego interfejsu graficznego, prze³±czanie pomiêdzy widokami, rysowanie wykresów oraz nawigacja po nim, wy¶wietlanie wyników oraz logów predykcji
	\item  \textbf{Konrad Dobro¶}
	
	Implementacja pobierania bazy z sieci, wczytywania, interpolacji oraz normalizacji danych, podzia³ danych na treningowe i testowe, struktura silnika predykcji, testowanie ró¿nych modeli sieci neuronowych, wytrenowanie ostatecznych modeli
	
\end{itemize}

Wspólnie zajmowali¶my siê wyszukiwaniem informacji przydatnych w rozwoju projektu, tworzeniem prymitywnego prototypu, pisaniem testów dla elementów które stworzyli¶my, a tak¿e tworzeniem dokumentacji.
Dodatkowo za ka¿dym razem recenzowali¶my siê nawzajem w sprawie wprowadzanych zmian.

\subsection{Etapy przebiegu pracy}

Prace nad projektem przebiega³y dosyæ nieregularnie. Pod koniec semestru letniego uda³o siê uzyskaæ prototyp o minimalnej funkcjonalno¶ci. W trakcie przerwy semestralnej prace nad projektem spowolni³y. Najwiêksza czê¶æ projektu powsta³a w trakcie semestru zimowego. 

Wyszczególniæ mo¿emy nastêpuj±ce etapy prac:

\subsubsection{Zapoznanie z tematyk± projektu oraz konfiguracja ¶rodowiska}

Czas trwania: 03.2018 - 04.2018
\newline
Osi±gniête cele:
\begin{itemize}
	\item zapoznanie siê z pojêciem arytmii, na czym polega, jak mo¿na j± wykrywaæ
	\item zapoznanie siê z postaci± wykresu EKG, co dok³adnie przedstawia
	\item zapoznanie siê z dzia³aniem sieci neuronowych oraz jak mo¿na j± wykorzystaæ do przewidywania wyst±pienia arytmii
	\item utworzenie ¶rodowiska - repozytorium, CI, narzêdzia organizacji pracy
	\item research technologii
\end{itemize}

\subsubsection{Zintegrowanie bazy danych}

Czas trwania: 04.2018 - 05.2018
\newline
Osi±gniête cele:
\begin{itemize}
	\item zapoznanie siê ze struktur± wykorzystywanej bazy EKG
	\item pobranie bazy danych
	\item wyodrêbnienie wymaganych danych z bazy
\end{itemize}

\subsubsection{Stworzenie prototypu}

Czas trwania: 05.2018 - 06.2018
\newline
Osi±gniête cele:
\begin{itemize}
	\item stworzenie prostego modelu sieci
	\item okre¶lenie formatu danych na wej¶ciu sieci neuronowej
	\item implementacja podstawowych operacji na danych
	\item przygotowanie danych dla takiego modelu
	\item przetestowanie dzia³ania przygotowanej sieci
\end{itemize}

\subsubsection{Struktura projektu oraz interfejsu}

Czas trwania: 07.2018 - 09.2018
\newline
Osi±gniête cele:
\begin{itemize}
	\item wyodrêbnienie w projekcie poszczególnych modu³ów
	\item okre¶lenie architektury modelu predykcji
	\item wstêpny projekt interfejsu graficznego
\end{itemize}

\subsubsection{Implementacja interfejsu oraz testy innych modeli sieci}

Czas trwania: 09.2018 - 10.2018
\newline
Osi±gniête cele:
\begin{itemize}
	\item implementacja podstawowego interfejsu graficznego
	\item redukcja szumów o niskich czêstotliwo¶ciach na przebiegu EKG
	\item stworzenie bardziej rozbudowanego modelu sieci neuronowej
	\item testy skuteczno¶ci predykcji z ró¿nymi parametrami
\end{itemize}

\subsubsection{Po³±czenie interfejsu z silnikiem predykcji}

Czas trwania: 10.2018 - 11.2018
\newline
Osi±gniête cele:
\begin{itemize}
	\item integracja modelu z interfejsem
	\item wytrenowanie ostatecznych sieci neuronowych
	\item dodanie informacji o arytmiach
\end{itemize}

\subsubsection{Poprawki oraz dokumentacja}

Czas trwania: 11.2018 - 12.2018
\newline
Osi±gniête cele:
\begin{itemize}
	\item poprawki interfejsu
	\item poprawki modelu
	\item stworzenie dokumentacji
\end{itemize}

\subsection{Wykorzystane narzêdzia}

Do zarz±dzania poszczególnymi zadaniami i ca³ym projektem wykorzystali¶my aplikacje webow± \textbf{Trello}. Do komunikacji w zespole wykorzystywali¶my komunikator \textbf{Slack}, którego zintegrowali¶my z serwisem \textbf{GitHub} co sprawi³o ¿e na kana³ wysy³ane by³y informacje o zmianach w repozytorium. Sporadycznie komunikowali¶my siê równie¿ przez \textbf{Skype}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{slack.png}
	\caption{Przyk³adowy zrzut ekranu z komunikatora Slack}
	\label{fig:slack}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{trello.png}
	\caption{Przyk³adowy zrzut ekranu z Trello}
	\label{fig:trello}
\end{figure}

Kod wraz z dokumentacj± trzymali¶my w repozytorium \textbf{Git} na platformie \textbf{GitHub}, któr± zintegrowali¶my z narzêdziem \textbf{SemaphoreCI} odpowiedzialnym za ci±g³± integracje oraz \textbf{CodeFactor} odpowiedzialnym za styl kodu. Do jego tworzenia wykorzystywali¶my miêdzy innymi takie narzêdzia jak \textbf{PyCharm} oraz \textbf{JupyterNotebook}, którego pliki zosta³y zaimportowane do projektu.

%TODO mo¿e dodac tez screen z codefactor
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{semaphore.png}
	\caption{Zrzut z SemaphoreCI}
	\label{fig:semaphore}
\end{figure}

Przy tworzeniu interfejsu pomocy by³ równie¿ program \textbf{QtDesigner}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{qt_designer.png}
	\caption{Wygl±d programu Qt Designer}
	\label{fig:qt_designer}
\end{figure}

Diagramy rysowali¶my przy pomocy narzêdzia \textbf{draw.io} oraz \textbf{Umlet}.

\section{\SectionTitleResults}
\label{sec:wyniki-projektu}

\subsection{Zrealizowane cele}

Uda³o nam siê zrealizowaæ nastêpuj±ce cele postawione na pocz±tku realizacji projektu:
\begin{itemize}
\item wy¶wietlanie wykresu EKG - wykres jest rysowany na podstawie wczytanych danych
\item mo¿liwo¶æ nawigowania po wykresie - mo¿liwe jest przesuwanie wykresu w obydwie strony, a tak¿e przeskok do wybranego fragmentu
\item mo¿liwo¶æ odtwarzania wykresu EKG - mo¿liwe jest odtwarzanie wykresu dla wczytanych danych co symuluje pracê w czasie rzeczywistym
\item stworzenie oraz przetestowanie skuteczno¶ci ró¿nych modeli sieci neuronowych - najwa¿niejsze z przetestowanych modeli zosta³y opisane w rozdziale 3.3.
\item zintegrowanie ostatecznych modeli z odtwarzaniem wykresu - w trakcie odtwarzania wykresu, co sekundê odbywa siê predykcja dla fragmentu EKG koñcz±cego siê w tym samym miejscu co aktualnie wy¶wietlany wykres. Wyniki predykcji wy¶wietlane s± w interfejsie, wpisywane do logów, a tak¿e wy¶wietlany jest wykres jak przebiega³a predykcja
\item mo¿liwo¶æ przegl±dania danych z oznaczonymi typami uderzeñ - stworzyli¶my zak³adkê na której wykres wy¶wietlany jest wraz z adnotacjami przy ka¿dym uderzeniu serca 
\item udostêpnienie informacji na temat arytmii - stworzyli¶my zak³adkê, w której znajduje siê lista arytmii wraz z ich opisami
\end{itemize}

\subsection{Najwa¿niejsze wyniki i wnioski}

% TODO Najwa¿niejsze wyniki
Z po¶ród testowanych przez nas modeli najlepszy wynik uzyska³ model oparty o sieæ konwolucyjn± z warstw± 'poolingu' rozmiaru 8, rozmiarem filtrów 16 i ilo¶ci filtrów kolejno 16, 8, 4. Jako wej¶cie bierze on 5 minutowy fragment rekordu. Nastêpnie dokonuje normalizacji, zmniejsza czêstotliwo¶æ sygna³u do 60 Hz i usuwa szumy niskiej czêstotliwo¶ci. Wynik przewiduje w okresie przysz³ych 2 minut. Jego skuteczno¶æ wynosi 84.21\%.

Zauwa¿yli¶my równie¿ ¿e sieci gêste du¿o gorzej radz± sobie z problemem predykcji arytmii na podstawie przebiegu EKG od sieci konwolucyjnych. Ich skuteczno¶æ oscyluje w okolicach 69\%. Maj± one tendencje do overfittingu. Powodem takiego stanu rzeczy jest najprawdopodobniej ogromna ilo¶æ cech w wej¶ciu jakim jest przebieg EKG, co bardzo utrudnia wykonanie predykcji. Sieci konwolucyjne jednak radz± sobie z tym problemem du¿o lepiej i osi±gaj± znacznie lepsze wyniki. Skuteczno¶æ sieci konwolucyjnych oscyluje w okolicy 83\%.

\subsection{Mo¿liwo¶ci rozwoju}

Pomimo, i¿ wszystkie postawione wymagania zosta³y spe³nione, to w naszej opinii projekt wci±¿ mo¿e byæ znacz±co rozszerzony. W trakcie tworzenia systemu znajdowali¶my pewne aspekty, których nie byli¶my w stanie bardziej rozbudowaæ, ze wzglêdu na czynniki takie jak ograniczenia czasowe lub konieczno¶æ dostêpu do niepublicznych baz danych, skupili¶my siê wiêc przede wszystkim na dostarczeniu wymaganej funkcjonalno¶ci. Poni¿ej znajduj± siê proponowane przez nas mo¿liwo¶ci rozwoju stworzonego systemu.

\begin{itemize}
\item \textbf{Inne formaty danych}: Do systemu mo¿na dodaæ obs³ugê wczytywania danych z plików o innych formatach ni¿ zrealizowane przez nas lub nawet pobieranie danych w czasie rzeczywistym z odpowiednich urz±dzeñ.
\item \textbf{Inne typy arytmii}: Bazê uwzglêdnianych rodzajów uderzeñ mo¿na znacz±co rozszerzyæ, np. poprzez bardziej szczegó³owe podzielenie wykorzystanych przez nas klas. Wymaga³o by to jednak dostêpu do znacznie bardziej rozbudowanej bazy danych, poniewa¿ w³a¶nie brak wystarczaj±cej ilo¶ci przypadków ogranicza³ nasze decyzje w tym zakresie.
\item \textbf{Nowe rodzaje klasyfikatorów}: Dodanie silników predykcji wykorzystuj±cych klasyfikatory inne ni¿ sieci neuronowe, np. SVM.
\item \textbf{Zmiana bazy treningowej}: Wytrenowanie istniej±cych sieci neuronowych na bardziej rozbudowanej bazie danych mog³oby podnie¶æ skuteczno¶æ predykcji, jednak obecnie brak jest publicznie dostêpnych i wiêkszych baz zapisów EKG.
\item \textbf{Rysowanie wykresów}: Rysowanie wykresów mo¿e zostaæ usprawnione poprzez zastosowanie grafiki wektorowej, co wi±za³oby siê ze zmian± wykorzystywanej biblioteki.
\end{itemize}

Uwa¿amy, ¿e stworzony przez nas system, dziêki zastosowaniu praktyk takich jak ci±g³a integracja czy recenzje kodu, dobrze nadaje siê do rozbudowywania funkcjonalno¶ci.

\subsection{Podsumowanie}

W ramach tej pracy in¿ynierskiej uda³o nam siê stworzyæ aplikacjê desktopow± spe³niaj±c± za³o¿one wymagania. Zarówno interfejs jaki i model predykcji spe³niaj± swoje zadanie. Uda³o nam siê równie¿ zbadaæ skuteczno¶æ predykcji arytmii przez ró¿ne modele predykcji. Projekt dostarcza równie¿ spore mo¿liwo¶ci je¿eli chodzi o rozwijanie i udoskonalania. 

Praca nad projektem pozwoli³a nam siê du¿o nauczyæ. Przede wszystkim zdobyli¶my cenne do¶wiadczenie pracy w zespole. Nauczyli¶my siê sprawnie rozwi±zywaæ problemy pojawiaj±ce siê w trakcie rozwoju projektu. Poznali¶my te¿ nowe technologie, które zosta³y wykorzystane przy tworzeniu systemu.

Z koñcowego efektu naszej pracy jeste¶my jak najbardziej zadowoleni.
%TODO KD mozesz cos dopisac bo krótko


% Tak dla pewno¶ci, ¿eby wypisa³y siê wszystkie materia³y, które mamy.
\nocite{*}

\bibliography{bibliografia}

\end{document}
